<h1 align="center">ğŸ›  Matt Parker</h1>
<p align="center">Systems Admin â€¢ Desktop Dev â€¢ Workflow Automation</p>

---

<p align="center"><a href="https://www.youtube.com/watch?v=--MY_0xDcHE">
  <img src="https://i.imgur.com/k6ZWMBv.png" alt="Watch the video" width="720">
</a></p>

## ğŸ§© About Me

- ğŸ§  I build practical solutions at the intersection of **system administration**, **desktop development**, and **workflow automation**
- ğŸ§° I watch for common issues, customer complaints, and repetitive tasks, then turn them into tools that make tech easier, faster, and more enjoyable to use
- ğŸ§‘â€ğŸ’» 20 years in tech, started in help desk, learned how real people use computers, how complex systems break, and what it takes to earn an end user's trust
- ğŸ§­ My rule: start with what the customer wants, then build the tech to match it
- ğŸ“ Documentation-first mindset, my handle **SysAdminDoc** comes from an intranet site I ran over 10 years ago to host internal docs, I kept the name because it still fits

---

## ğŸ”§ What I Build

I have spent 20 years in tech, starting in help desk, learning how real people use computers, how complex systems break, and what it takes to earn an end user's trust. That experience shapes how I build: tools should match how people think, stay simple, solve the real problem, make their job easier, and work the first time.

---

## ğŸ§° How I Work

I started writing tools as batch scripts, moved to PowerShell, and gradually rebuilt my toolbox into something cleaner, safer, and easier to maintain. Now I use AI assistants like Claude Code and Codex to accelerate development, but I treat their output as untrusted until it is thoroughly verified.

The real advantage is not typing faster, it is knowing what to check. Experienced developers move quickly because they validate assumptions, work in small steps, review diffs, and lean on tests. AI did not make "everyone a developer." It shifted the work from writing syntax to exercising judgment, and judgment is still the hard part. The tool matters less than the operator. It was never about the paintbrush, it was always about the artist.

My default is self-contained builds with minimal dependencies. UX polish matters, consistent design, dark themes, and the small details that make software feel complete. I automate repetitive work early, and I write docs that are clear, practical, and include examples that actually run.

---

## ğŸ§± Toolbox

**Languages:** PowerShell, Python, C#, JavaScript  
**Desktop:** WinUI 3, WPF, WinForms  
**Browser:** Userscripts, Chrome and Firefox extensions  
**Platforms:** Mostly Windows, cross-platform where it makes sense  
**Workflow:** CLI prototype â†’ GUI refinement â†’ single-binary packaging  

---

## â“ FAQ

**Why desktop tools instead of web apps?**  
The problems I solve are Windows-first, offline-friendly, and not worth depending on a server.

**Why self-contained builds?**  
For small utilities, one executable is easier to ship, run, and support than a pile of dependencies.
