# Start with what the customer wants, then build the tech to match it.

<a href="https://www.youtube.com/watch?v=--MY_0xDcHE">
  <img src="https://img.youtube.com/vi/--MY_0xDcHE/hqdefault.jpg" alt="Watch the video" width="720">
</a>

I build practical solutions at the intersection of **system administration**, **desktop development**, and **workflow automation**. Most of it exists because I got tired of doing something manually, or because the existing tools did not quite fit.

---

## What I Build

I have spent 20 years in tech, starting in help desk, learning how real people use computers, how complex systems break, and what it takes to earn an end user's trust. That experience shapes how I build: tools should match how people think, stay simple, solve the real problem, make their job easier, and work the first time.

Over time I also learned that great tools fail without great documentation. At every job, one of my first priorities is to document the systems, workflows, and procedures so the next person can succeed without tribal knowledge. That is where my handle **SysAdminDoc** came from. More than 10 years ago I ran an intranet site under that name to host my internal docs, and I kept the handle.

- **Desktop apps** with clean UI, converters, editors, and system utilities  
- **PowerShell automation** for deployments, configuration, and remote support  
- **Browser userscripts** and extensions that fix annoying web UX  
- **Medical imaging tooling** including DICOM helpers and PACS deployment automation  
- **Windows utilities** for firewall control, hardening, and system configuration  
- **Media tools** including downloaders and format converters  
- **Standalone executables** that ship as a single file and just run  

---

## How I Work

I started writing tools as batch scripts, moved to PowerShell, and gradually rebuilt my toolbox into something cleaner, safer, and easier to maintain. Now I use AI assistants like Claude Code and Codex to accelerate development, but I treat their output as untrusted until it is thoroughly verified.

The real advantage is not typing faster, it is knowing what to check. Experienced developers move quickly because they validate assumptions, work in small steps, review diffs, and lean on tests. AI did not make "everyone a developer." It shifted the work from writing syntax to exercising judgment, and judgment is still the hard part. The tool matters less than the operator. It was never about the paintbrush, it was always about the artist.

My default is self-contained builds with minimal dependencies. UX polish matters, consistent design, dark themes, and the small details that make software feel complete. I automate repetitive work early, and I write docs that are clear, practical, and include examples that actually run.


---

## Toolbox

**Languages:** PowerShell, Python, C#, JavaScript  
**Desktop:** WinUI 3, WPF, WinForms  
**Browser:** Userscripts, Chrome and Firefox extensions  
**Platforms:** Mostly Windows, cross-platform where it makes sense  
**Workflow:** CLI prototype → GUI refinement → single-binary packaging  

---

## FAQ

**Why desktop tools instead of web apps?**  
The problems I solve are Windows-first, offline-friendly, and not worth depending on a server.

**Why self-contained builds?**  
For small utilities, one executable is easier to ship, run, and support than a pile of dependencies.
